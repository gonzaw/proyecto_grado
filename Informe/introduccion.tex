%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Records Extensibles - Introducción
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introducción}
\label{ch:1}

Los records extensibles son una herramienta muy útil en la programación. Surgen como una respuesta a un problema que tienen los lenguajes de programacion estáticos en cuanto a records: ¿Cómo puedo modificar la estructura de un record ya definido?

En los lenguajes de programación fuertemente tipados modernos no existe una forma primitiva de definir y manipular records extensibles. Algunos lenguajes ni siquiera permiten definirlos.

En este trabajo se presenta una manera de definir records extensibles en un lenguaje de programación con \textit{tipos dependientes} llamado Idris.

\section{Records Extensibles}

En varios lenguajes de programación con tipos estáticos, es posible definir una estructura estática llamada 'record'. Un record es una estructura heterogénea que permite agrupar valores de varios tipos en un único objeto, asociando una etiqueta o nombre a cada uno de esos valores.
Un ejemplo de la definición de un tipo record en Haskell sería la siguiente:

\begin{code}
data Persona = Persona { edad :: Int, nombre :: String}
\end{code}

En muchos lenguajes de programación, una desventaja que tienen los records es que una vez definidos, no es posible modificar su estructura de forma dinámica. Tomando el ejemplo anterior, si uno quisiera tener un nuevo record con los mismos campos de \texttt{Persona} pero con un nuevo campo adicional, como \texttt{apellido}, entonces uno solo podría definirlo de una de estas dos formas:
\begin{itemize}[noitemsep]
\item Definir un nuevo record con esos 3 campos
\item Crear un nuevo record que contenga el campo \texttt{apellido} y otro campo de tipo \texttt{Persona}
\end{itemize}

En ninguno de ambos enfoques es posible obtener el nuevo record extendiendo el anterior de manera dinámica. Es decir, siempre es necesario definir un nuevo tipo, indicando que es un record e indicando sus campos.

Los records extensibles intentan resolver este problema. Si \texttt{Persona} fuera un record extensible, entonces definir un nuevo record idéntico a él, pero con un campo adicional, sería tan fácil como tomar un record de tipo \texttt{Persona} existente, y simplemente agregarle el nuevo campo \texttt{apellido} con su valor correspondiente. A continuación se muestra un ejemplo de record extensible, con una sintaxis hipotética similar a Haskell:

\begin{code}
p :: Persona
p = Persona { edad = 20, nombre = "Juan" }

pExtensible :: Persona + { apellido :: String }
pExtensible = p + { apellido = "Sanchez" }
\end{code}

El tipo del nuevo record debería reflejar el hecho de que es una copia de \texttt{Persona} pero con el campo adicional utilizado. Uno debería poder, por ejemplo, acceder al campo \texttt{apellido} del nuevo record como uno lo haría con cualquier otro record arbitrario.

Para poder implementar un record extensible, es necesario poder codificar toda la información del record. Esta información incluye las etiquetas que acepta el record, y el tipo de los valores asociados a cada una de esas etiquetas. 

Algunos lenguajes permiten implementar records extensibles con primitivas del lenguaje, pero requiere de sintaxis y semántica especial para records extensibles, y no es posible implementarlos con primitivas del lenguaje más básicas. En este trabajo describiremos la implementación de records extensibles mediante el uso de tipos \textit{dependientes}.

\section{Tipos Dependientes}

Los tipos dependientes son tipos que dependen de valores. Por ejemplo, veamos la definición del tipo \textit{vector} que son listas cuyo largo es anotado en su tipo:

\begin{code}
data Vect : Nat -> Type -> Type where
  [] : Vect 0 A
  (::) : (x : A) -> (xs : Vect n A) -> Vect (n + 1) A
\end{code}

Un valor del tipo \texttt{Vect 1 String} es una lista que contiene 1 string, mientras que un valor del tipo \texttt{Vect 10 String} es una lista que contiene 10 strings.

Tener valores en el tipo permite poder restringir el uso de funciones a determinados tipos que tengan un valores específicos. Como ejemplo se tiene la siguiente funcion

\begin{code}
head : Vect (n + 1) a -> a
head (x :: xs) = x
\end{code}

Esta funcion obtiene el primer valor de un vector. Es una funcion total, ya que restringe su uso solamente a vectores que tengan un largo mayor a 0, por lo que tal vector siempre va a tener por lo menos un elemento para obtener.

En relacion a records extensibles, los tipos dependientes hacen posible que dentro del tipo del record puedan existir valores para poder ser manipulados, como podrian ser la lista de etiquetas del record. Como esta informacion se encuentra en el tipo del record, es posible definir tipos y funciones que accedan a ella y la manipulen para poder definir todas las funcionalidades de records extensibles.

\section{Idris}

En este trabajo se decidio utilizar el lenguaje de programacion \textit{Idris} para llevar a cabo la investigacion del uso de tipos dependientes aplicados a la definicion de records extensibles. Idris es un lenguaje de programacion funcional con tipos dependientes, con sintaxis similar a Haskell.

A continuacion se muestra un ejemplo de codigo escrito en Idris:
\begin{code}
length : (xs : Vect n a) -> Nat
length [] = 0
length (x::xs) = 1 + length xs
\end{code}

El código descrito en la sección anterior también está en Idris.

Otro lenguaje que cumple con los requisitos es \textit{Agda}. \textit{Agda} es otro lenguaje funcional con tipos dependientes. Sin embargo, se decidió utilizar Idris para investigar las funcionalidades de este nuevo lenguaje.
Por este motivo, todas las conclusiones obtenidas en este informe pueden ser aplicadas a \textit{Agda} también.

La version de Idris utilizada en este trabajo es la 0.12.0.
