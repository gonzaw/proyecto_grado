%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Trabajo A Futuro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Trabajo a futuro}
\label{ch:6}

En este trabajo se encontraron varias tareas para mejorar esta implementación de records extensibles.
\begin{itemize}
\item Una posible tarea a futuro es terminar de implementar las demás funciones y predicados de \textit{HList} de Haskell que faltan implementar.
\item En el diseño de la biblioteca y del caso de estudio, hubo varios predicados y funciones duplicados para \texttt{List (lty, Type)} y \texttt{List String}. Predicados como \texttt{IsLeftUnion}, \texttt{DeleteLabelAt}, y muchas otras. Una mejora es crear predicados y funciones parametrizadas por \texttt{List a}, con una restricción sobre este \texttt{a} de que contenga una etiqueta o valor String. De este modo no se repite código ni se realiza más esfuerzo en probar todos los lemas para cada predicado en particular.
\item Todavia existen muchos lemas y teoremas que relacionan todos los predicados y tipos creados que podrían ser muy útiles. Es fundamental que la biblioteca contenga estos teoremas para que el programador que la use no tenga que probarlos por sí solo cada vez (lo cual va a requerir que el usuario de esta biblioteca conozca su comportamiento interno, que es necesario para probar los teoremas).
\item Para algunos predicados se crearon funciones que computan su mismo resultado. Por ejemplo, para el predicado \texttt{IsLeftUnion} se implementó la función \texttt{leftUnion}. Un buen trabajo a futuro sería implementar las funciones análogas de todos los predicados definidos, y definir todos los posibles teoremas y lemas interesantes entre esas funciones y los distintos predicados.
\item La implementación actual funciona sobre listas ordenadas. Esto hace que \texttt{Record [('A', Nat), ('B', Nat)]} sea distinto de \texttt{Record [('B', Nat), ('A', Nat)]}, cuando en realidad tal orden no es necesario para utilizar las funciones definidas para records. Un posible trabajo es parametrizar el tipo del record por un tipo abstracto. Este tipo abstracto debe funcionar como una colección de etiquetas y tipos, y debe permitir operaciones como \texttt{head}, \texttt{index}, \texttt{cons}, \texttt{nil}, entre otras. Al funcionar como tipo abstracto se podría utilizar cualquier tipo que cumpla esas propiedades, eligiendo el que se adecúe a la situación del usuario. Se podría utilizar árboles binarios, árboles Red-Black, Fingertrees, etc.
\item Actualmente los records se implementaron siguiendo los pasos de \textit{HList} de Haskell. Sin embargo, pueden existir otras implementaciones que sean mejores en otras situaciones. Una buena tarea a futuro es diseñar la biblioteca utilizando el record como tipo abstracto, tal que la implementación misma del record pueda variar sin que los usuarios de la biblioteca sean afectados. 
\item Como se vió en la introducción, los conceptos visitados en este trabajo aplican tanto a \textit{Agda} como a \textit{Idris}. Sería interesante estudiar replicar esta implementación en Agda.
\item Se puede mejorar los mensajes de error en la generación automática de errores. Cuando se utiliza \texttt{TypeOrUnit}, si el compilador no puede generar el predicado esperado, entonces se muestra un error de unificación de \texttt{TypeOrUnit} con el tipo esperado. Se puede investigar una nueva forma de utilizar \texttt{TypeOrUnit} para mostrar mejores mensajes de error. Se debería poder asignar un mensaje de error a cada aplicación de \texttt{TypeOrUnit}, como por ejemplo el mensaje \textit{"El elemento a agregar ya existe"} al llamar a \texttt{consRec}.
\end{itemize}
