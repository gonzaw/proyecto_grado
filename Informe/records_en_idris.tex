%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Records Extensibles en Idris
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Records Extensibles en Idris}
\label{ch:3}

\section{HList actualizado}

En este trabajo se decidió implementar las listas heterogéneas de una forma distinta a la que utiliza Idris en general. Las listas heterogéneas de Idris permiten incluir cualquier tipo arbitrario, pero eso no es suficiente al momento de poder implementar records extensibles. Para implementar records extensibles, no solo es necesario poder tener tipos arbitrarios en tal lista, sino que es necesario asociar una etiqueta a cada uno de esos tipos.

Una posible implementación es la de \texttt{Record} de Haskell definida en el capítulo anterior. En ésta se define un tipo \texttt{Tagged s b} que contenga un \textit{phantom type}, de tal forma que luego se utiliza una lista de esos tipos. Sin embargo se decidió no utilizar esta implementación, ya que necesita definir tipos auxiliarse (como \texttt{Tagged}), y a su vez necesita definir predicados específicos para esta implementación, como el predicado que indica que la lista heterogénea está compuesta solamente por valores del tipo \texttt{Tagged}.

Se decidió utilizar una solución más simple, en donde se reimplementa  \texttt{HList} para que contenga la etiqueta junto al tipo

\begin{code}
LabelList : Type -> Type
LabelList lty = List (lty, Type)

data HList : LabelList lty -> Type where
  Nil : HList []
  (::) : {lbl : lty} -> (val : t) -> HList ts -> 
    HList ((lbl,t) :: ts)
\end{code}

El tipo \texttt{LabelList} representa una lista de tipos, junto a una etiqueta para cada uno de esos tipos. Las etiquetas pueden ser de cualquier tipo, pero generalmente se utiliza \texttt{String} para poder nombrarlas mejor. Un ejemplo de tal lista sería \texttt{[("1", Nat),("2", String)] : LabelList String}.
El resto de la implementación es idéntica a la de \texttt{HList} de Idris, con la diferencia de que se debe pasar no solo el valor sino la etiqueta de su campo también.

\section{Definición de Records Extensibles}

Al igual que la implementación de records extensibles en Haskell vista en la sección anterior, en este trabajo se decidió implementar records extensibles utilizando una lista heterogénea, cuyo tipo contiene una lista de etiquetas que no deben ser repetidas.

Para comenzar con esta implementación, se necesita que las etiquetas de los records puedan ser comparadas para verificar que no sean repetidas. En este trabajo se decidió utilizar la \textit{typeclass} \texttt{DecEq lty} para las etiquetas de tipo \texttt{lty}. Al ser las etiquetas de un tipo que tienen una instancia de esa typeclass, la igualdad de cualquier par de valores de etiquetas es decidible, por lo que las etiquetas pueden ser comparadas.

Como en la implementación en Haskell se decide utilizar un predicado que indica que una lista de valores no tiene repetidos.
En Idris es posible codificar esta propiedad en un tipo de datos:

\begin{code}
data IsSet : List t -> Type where
  IsSetNil : IsSet []
  IsSetCons : Not (Elem x xs) -> IsSet xs -> IsSet (x :: xs)
\end{code}

El tipo \texttt{IsSet ls} funciona efectivamente como un predicado lógico, el cual indica que la lista \texttt{ls} es un conjunto que no tiene elementos repetidos.

Las pruebas de este predicado se construyen de forma constructiva. Primero se prueba que la lista vacía no contiene repetidos, y luego para el caso recursivo si se agrega un elemento a una lista, la lista resultante no va a tener repetidos solamente si el elemento a agregar no se encuentra en la lista original.

Como para el caso de records extensibles se manejan listas de pares de etiquetas y tipos, se definen los siguientes tipos y funciones útiles para manejarlos:

\begin{code}
ElemLabel : lty -> LabelList lty -> Type
ElemLabel lbl ts = Elem lbl (labelsOf ts)

isElemLabel : DecEq lty => (lbl : lty) -> (ts : LabelList lty) -> Dec (Elem lbl (labelsOf ts))
isElemLabel lbl ts = isElem lbl (labelsOf ts)

labelsOf : LabelList lty -> List lty
labelsOf = map fst

IsLabelSet : LabelList lty -> Type
IsLabelSet ts = IsSet (labelsOf ts)  
\end{code}

El predicado \texttt{IsLabelSet ts} indica que para la lista de etiquetas y tipos \texttt{ts} no existen etiquetas repetidas.
El predicado \texttt{ElemLabel lbl ts} indica que la etiqueta \texttt{lbl} pertenece a la lista de etiquetas \texttt{ts}.
\texttt{isElemLabel} es una función de decisión, donde para cualquier etiqueta y cualquier lista, se puede probar que tal etiqueta pertenece a esa lista o no.

Obtener una definicion de record extensible es simplemente necesitar una lista heterogenea etiquetada, y una prueba de que las etiquetas no son repetidas.

\begin{code}
data Record : LabelList lty -> Type where
    MkRecord : IsLabelSet ts -> HList ts -> Record ts
\end{code}

Un caso base que se puede definir es el record vacío

\begin{code}
emptyRec : Record []
emptyRec = MkRecord IsSetNil {ts=[]} [] 
\end{code}

A su vez se pueden crear funciones que proyectan sobre los campos del constructor del record. En particular, se puede convertir un record a un HList, y dado un record se puede obtener la prueba de que sus etiquetas forman un conjunto.

\begin{code}
recToHList : Record ts -> HList ts
recToHList (MkRecord _ hs) = hs

recLblIsSet : Record ts -> IsLabelSet ts
recLblIsSet (MkRecord lsIsSet _ ) = lsIsSet  
\end{code}

\section{Extensión de records dinámicamente}

La funcionalidad más importante de records extensibles es la de poder extender tal record con un nuevo campo. Esta funcionalidad puede definirse de esta forma:

\begin{code}
consRec : DecEq lty => {ts : LabelList lty} -> {t : Type} ->
    (l : lty) -> (val : t) ->  Record ts -> 
    {notElem : Not (ElemLabel l ts)} -> Record ((l,t) :: ts)
consRec l val (MkRecord subLabelSet hs) {notElem} = 
    MkRecord (IsSetCons notElem subLabelSet) (val :: hs)
\end{code}

Antes que nada se necesita que el tipo de etiquetas admita igualdad, utilizando la restricción \texttt{DecEq lty}. Luego, se necesita un record ya existente \texttt{Record ts}, el nuevo valor \texttt{val} y la etiqueta del nuevo campo \texttt{lbl}. A su vez es necesaria una prueba de que la etiqueta nueva no esté repetida en las etiquetas ya existentes del record, representado por el tipo \texttt{Not (ElemLabel lbl ts)}. Si se cumplen estas condiciones entonces es posible crear un nuevo record con el nuevo campo, el cual es reflejado en el tipo \texttt{Record ((lbl,t) :: ts)}, donde se agrega el par con la nueva etiqueta y el tipo del valor a la lista de tipos y etiquetas original.

\subsection{Construcción de términos de prueba}

El principal problema que ocurre al utilizar esa función se da por el parámetro \texttt{notElem}. Para poder llamar a esta función es necesario construir una prueba de que la nueva etiqueta a agregar al record no está repetida en el record ya existente.

Una primera opción es generar la prueba manualmente, pero esto resulta tedioso e impráctico, ya que sería necesario construir ese término de prueba cada vez que se llame a la función.

Una segunda opción es utilizar la decidibilidad del predicado a instanciar. Al tener un tipo decidible, es posible utilizar un truco del typechecker forzando la unificación del tipo decidible con el tipo mismo o su contradicción.
Básicamente, si uno puede generar un valor del tipo \texttt{Dec p}, entonces puede unificarlo con \texttt{p} en tiempo de compilación, o con \texttt{Not p}. Si en tiempo de compilación la unificación falla, entonces el typechecker falla.

En este caso en particular, es necesario poder obtener un valor de tipo \texttt{Dec (ElemLabel lbl ts)}, lo cual puede hacerse con la función \texttt{isElemLabel}.

Para forzar la unificación, se utilizan estas funciones auxiliares:

\begin{code}
getYes : (d : Dec p) -> case d of { No _ => (); Yes _ => p}
getYes (No _ ) = ()
getYes (Yes yes) = yes

getNo : (d : Dec p) -> case d of { No _ => Not p; Yes _ => ()}
getNo (No no) = no
getNo (Yes _ ) = ()
\end{code}

Se analizará el caso de \texttt{getYes} primero, y luego se aplicará el mismo razonamiento para \texttt{getNo}.
\texttt{getYes} toma un tipo \texttt{Dec p} y el tipo que retorna es una computación, la cual hace \textit{pattern matching} sobre el valor de \texttt{Dec p}. Esta computación es ejecutada en tiempo de typechecking, y tiene dos opciones: o retorna el tipo \textit{top} \texttt{()}, o retorna el tipo \texttt{p}.
En tiempo de typechecking, se hace pattern matching sobre \texttt{Dec p}. Si la prueba es de \texttt{No}, entonces se retorna el valor \texttt{()} (que efectivamente es un valor del tipo \texttt{()}). Sin embargo, si la prueba es de \texttt{Yes}, entonces ya se tiene un valor de tipo \texttt{p}, por lo cual se retorna ese. El pattern matching no solo permite tener una bifurcación sobre cuál valor retornar, sino también sobre cuál es el tipo de este valor retornado, pudiendo retornar dos valores con tipos totalmente distintos.

La función \texttt{getNo} es idéntica, pero retornando un valor del tipo \texttt{Not p}.

A continuación se muestran ejemplos del uso de estas funciones:

\begin{code}
okYes : Elem "L1" ["L1"]
okYes = getYes $ isElem "L1" ["L1"]

okNo : Not (Elem "L1" ["L2"])
okNo = getNo $ isElem "L1" ["L2"]

badYes : Elem "L1" ["L2"]
badYes = getYes $ isElem "L1" ["L2"]

badNo : Not (Elem "L1" ["L1"])
badNo = getNo $ isElem "L1" ["L1"]
\end{code}

En el caso de \texttt{okYes}, la función \texttt{isElem} es computada en tiempo de typechecking, retornando la prueba de \texttt{Elem "Lbl1" ["L1"]}. Luego \texttt{getYes} hacer pattern matching sobre tal valor, encuentra que se corresponde al caso de \texttt{Yes}, por lo cual retorna ese mismo valor como un valor del tipo \texttt{Elem "L1" ["L1"]}. No ocurre lo mismo para el caso de \texttt{badYes}, donde en tiempo de typechecking se retorna la prueba de \texttt{Not (Elem "L1" ["L2"]}. Al realizar pattern matching entonces \texttt{getYes} retorna \texttt{()}, lo cual no puede ser unificado con \texttt{Elem "L1" ["L2"]}, mostrando error de typechecking.

Lo mismo ocurre de forma inversa con \texttt{okNo} y \texttt{badNo}.

Con este truco se puede generar una prueba automática de cualquier predicado decidible, por lo que se puede simplificar el uso de \texttt{consRec}.
Ahora puede ser utilizado de esta forma:

\begin{code}
extendedRec : Record [("Nombre", String)]
extendedRec = consRec "Nombre" "Juan" {notElem=(getNo $ isElemLabel "Nombre" [])} emptyRec
\end{code}

\subsection{Generación de pruebas automática}

Al utilizar \texttt{getYes} y \texttt{getNo} se simplifica bastante el proceso de construcción de pruebas, pero de todas formas se necesita llamar a esas funciones manualmente. Es posible mejorar este sistema.

A continuación se muestra un nuevo truco utiliza el mismo concepto del anterior, donde se realiza pattern matching sobre un tipo decidible en tiempo de typechecking para unificar tipos. Sin embargo, el pattern matching se realiza en el tipo mismo y no en una función auxiliar.

Esto es posible gracias a este tipo y esta función:

\begin{code}
TypeOrUnit : Dec p -> Type -> Type
TypeOrUnit (Yes yes) res = res
TypeOrUnit (No _) _ = ()

mkTypeOrUnit : (d : Dec p) -> (cnst : p -> res) -> TypeOrUnit d res
mkTypeOrUnit (Yes prf) cnst = cnst prf
mkTypeOrUnit (No _) _ = ()
\begin{code}

El tipo \texttt{TypeOrUnit} permite discriminar un tipo en dos casos:
\begin{itemize}
\item Si \texttt{Dec p} incluye una prueba de \texttt{p}, entonces se obtiene el tipo deseado.
\item Si \texttt{Dec p} incluye una contradiccion de \textt{p}, entonces se obtiene el tipo \texttt{()}
\end{itemize}

Este metodo funciona cuando se necesita unificar un tipo \texttt{type} y \texttt{TypeOrUnit dec type}. Si se tiene una prueba de \textt{p} entonces la unificación va a dar correcta, pero si no se tiene una prueba entonces va a fallar el typechecking.

\texttt{mkTypeOrUnit} es el constructor de este tipo. Necesita la prueba o contradicción de \texttt{p} y una función que construya el tipo deseado dada una prueba de \texttt{p}. Este constructor es utilizado solamente cuando se tiene tal prueba.

Como ejemplo, se tiene una función \texttt{addNat} que debe agregar un natural a una lista solamente si ya pertenece a ésta, y de caso contrario tirar error de typechecking.

\begin{code}
-- isElem : DecEq a => (x : a) -> (xs : List a) -> Dec (Elem x xs)
addNat : (n : Nat) -> (ns : List Nat) -> TypeOrUnit (isElem n ns) (List Nat)
addNat n ns = mkTypeOrUnit (isElem n ns) (\isElem => Prelude.List.(::) n ns)

myListOk : List Nat
myListOk = addNat 10 [10] -- [10, 10]

myListBad1 : List Nat
myListBad1 = addNat 9 [10] -- Error de typechecking

myListBad2 : Nat -> List Nat
myListBad2 n = addNat n [10] -- Error de typechecking
\end{code}

La función \texttt{addNat} hace uso de \texttt{TypeOrUnit}, forzando que se cumpla el predicado \texttt{Elem n ns}. Si no se cumple la función retorna \texttt{()}. La unificación se realiza en la llamada en \texttt{myListOk}. La llamada a \texttt{addNat [10] 10} retorna el tipo \texttt{TypeOrUnit (isElem 10 [10]) (List Nat)}, pero \texttt{myListOk} espera \texttt{List Nat}. En tiempo de typechecking se evalúa \texttt{isElem 10 [10]}, el cual retorna una prueba de \texttt{Elem 10 [10]}, por lo que \texttt{TypeOrUnit (isElem 10 [10]) (List Nat)} evalúa a \texttt{List Nat}, compilando correctamente el código.

En el caso de \texttt{myListBad1}, como \texttt{isElem 9 [10]} retorna una contradicción de \texttt{Elem 9 [10]}, \texttt{TypeOrUnit (isElem 9 [10]) (List Nat)} evalúa a \texttt{()}, el cual no puede ser unificado con \texttt{List Nat}, tirando un error de typechecking.

Otro caso de error ocurre con \texttt{myListBad2}. En este caso es imposible evaluar completamente \texttt{isElem n [10]}, ya que no se conoce el valor de \texttt{n} en tiempo de typechecking. Por lo tanto no se puede evaluar \texttt{TypeOrUnit (isElem n [10]) (List Nat)}, lo cual hace que falle la unificación con \texttt{List Nat}.

Por lo tanto, con este método es posible forzar, en tiempo de compilación, a que se cumpla un predicado específico. Si el predicado puede ser evaluado y es correcto, entonces el código compila correctamente. Si el predicado no puede ser evaluado, o puede pero resulta ser incorrecto, entonces el código no compila.

Para poder aplicar este método a los records, es necesario poder tener una función que obtenga una prueba o contradicción de que los campos del record no tienen repetidos. Esa función es la siguiente:

\begin{code}
ifNotSetHereThenNeitherThere : Not (IsSet xs) -> Not (IsSet (x :: xs))
ifNotSetHereThenNeitherThere notXsIsSet (IsSetCons xIsInXs xsIsSet) = notXsIsSet xsIsSet

ifIsElemThenConsIsNotSet : Elem x xs -> Not (IsSet (x :: xs))      
ifIsElemThenConsIsNotSet xIsInXs (IsSetCons notXIsInXs xsIsSet) = notXIsInXs xIsInXs

isSet : DecEq t => (xs : List t) -> Dec (IsSet xs)
isSet [] = Yes IsSetNil
isSet (x :: xs) with (isSet xs)
  isSet (x :: xs) | No notXsIsSet = No $ ifNotSetHereThenNeitherThere notXsIsSet
  isSet (x :: xs) | Yes xsIsSet with (isElem x xs)
    isSet (x :: xs) | Yes xsIsSet | No notXInXs = Yes $ IsSetCons notXInXs xsIsSet
    isSet (x :: xs) | Yes xsIsSet | Yes xInXs = No $ ifIsElemThenConsIsNotSet xInXs

isLabelSet : DecEq lty => (ts : LabelList lty) -> Dec (IsLabelSet ts)
isLabelSet ts = isSet (labelsOf ts)
\end{code}

\texttt{ifNotSetHereThenNeitherThere) y \texttt{ifIsElemThenConsIsNotSet} son dos lemas necesarios para poder definir \texttt{isSet}. \texttt{isSet} toma una lista de valores que pueden chequearse por igualdad, y retorna o una prueba de que no tiene repetidos o una prueba de que los hay.

\texttt{isLabelSet} simplemente permite aplicar la función \texttt{isSet} al tipo \texttt{IsLabelSet}.

La implementación de \texttt{isSet} realiza un análisis de casos sobre el largo de la lista. Para el caso de lista vacía ésta no tiene elementos repetidos por definición. Para el caso de que tenga un elemento seguido de la cola de la lista, realiza dos análisis de casos seguidos, verificando si la cola de la lista no tiene repetidos (utilizando recursión), y luego verificando que la cabeza de la lista no pertenezca a la cola de ésta. En algunos casos utiliza los lemas definidos previamente si es necesario.

En Idris un análisis de casos que tiene impacto en los tipos utiliza el identificador \texttt{with}. Su sintaxis es del estilo

\begin{code}
func params with (expresion)
  func params | Caso1 val1 = ...
  func params | Caso2 val2 = ...
\end{code}

La expressión dentro del \texttt{with} es deconstruida en sus constructores correspondientes. La diferencia con \texttt{case} es que \texttt{with} permite redefinir los parámetros anteriores según el resultado del matcheo de la expresión. Al ser Idris un lenguaje con tipos dependientes pueden ocurrir situaciones donde una expresión matchee solamente cuando otros valores previos de la definición tienen valores fijos. Un ejemplo es el siguiente:

\begin{code}
eq : (n : Nat) -> (m : Nat) -> Bool  
eq n m  with (decEq n m)
  eq n n | Yes Refl = True
  eq n m | No notNEqM = False
\end{code}

El matcheo de \texttt{Yes} tiene un valor de tipo \texttt{val : n = m}. Como la única forma de que se tenga una prueba de ambos es que \texttt{n} sea efectivamente \texttt{m}, se puede unificar \texttt{val} con \texttt{Refl : n = n} y cambiar \texttt{eq n m} por \texttt{eq n n} en la definición de la función.


Luego de tener la función de decidibilidad anterior definida, es posible aplicar el tipo \texttt{TypeOrUnit} a los records de la siguiente forma:

\begin{code}
RecordOrUnit : DecEq lty => LabelList lty -> Type
RecordOrUnit ts = TypeOrUnit (isLabelSet ts) (Record ts)
\end{code}

\texttt{RecordOrUnit ts} evalúa a \texttt{Record ts} cuando se cumple que \texttt{ts} no tiene repetidos, pero evalúa a \texttt{()} cuando tiene repetidos.

Con este tipo es posible tener la siguiente función que extiende un record:

\begin{code}
consRecAuto : DecEq lty => {ts : LabelList lty} -> {t : Type} -> (l : lty) -> (val : t) -> Record ts -> RecordOrUnit ((l,t) :: ts)
consRecAuto {ts} {t} l val (MkRecord tsIsLabelSet hs) = mkTypeOrUnit (isLabelSet ((l, t) :: ts)) (\isLabelSet => MkRecord isLabelSet (val :: hs))
\end{code}

Esta función es idéntica a \texttt{consRec}, solamente que no es necesario pasar una prueba de \texttt{Not (ElemLabel l ts)}. Ahora se calcula automáticamente la prueba de \texttt{IsLabelSet ((l,t) :: ts))}  en tiempo de typechecking y se impacta en el tipo resultante \texttt{RecordOrUnit ((l,t) :: ts)}.

Con esta nueva función es posible extender un record de la siguiente manera:

\begin{code}
extendedRec1 : Record [("Nombre", String)]
extendedRec1 = consRecAuto "Nombre" "Juan" emptyRec

extendedRec2 : Record [("Edad", Nat), ("Nombre", String)]
extendedRec2 = consRecAuto "Edad" 24 extendedRec1
\end{code}

Otra función útil que se puede definir con este método es la que toma una lista heterogénea y la convierte en un record:

\begin{code}
hListToRecAuto : DecEq lty => (ts : LabelList lty) -> HList ts -> RecordOrUnit ts
hListToRecAuto ts hs = mkTypeOrUnit (isLabelSet ts) (\tsIsSet => MkRecord tsIsSet hs) 
\end{code}

Esta función permite construir records solamente indicando su lista de campos, y luego su lista de valores. Un ejemplo es el siguiente:

\begin{code}
record : Record [("Apellido", String), ("Nombre", String)]
record = hListToRecAuto [("Apellido", String), ("Nombre", String)] ["Sanchez", "Juan"]
\end{code}

\section{Proyección de un record}

Dado un record, una funcionalidad importante que se puede tener es poder filtrar el record dada una lista de etiquetas. En un caso se debería poder obtener un nuevo record con solo los campos indicados en esa lista de etiquetas, y en otro caso se debería poder obtener un record con campos que no estén en esa lista.

Ésta se llama proyección de un record, y es otra funcionalidad clave de los records extensibles.




\section{Alternativas de HList en Idris}

El sistema de tipos de Idris permite definir tipos de muchas maneras, por lo cual en su momento se investigaron otras formas distintas de implementar HList.
A continuación se describen tales formas, indicando por qué no se optó por cada una ellas.

\subsection{Dinámico}

\begin{code}
data HValue : Type where
    HVal: {A : Type} -> (x : A) -> HValue

HList : Type
HList = List HValue 
\end{code}

Este tipo se asemeja al tipo \texttt{Dynamic} utilizado a veces en Haskell, o a \texttt{Object} en Java/C\#. Esta HList mantiene valores de tipos arbitrarios dentro de ella, pero no proporciona ninguna información de ellos en su tipo. Cada valor es simplemente reconocido como \texttt{HValue}, y no es posible conocer su tipo u operar con él de ninguna forma. Solo es posible insertar elementos, y manipularlos en la lista (eliminarlos, reordenarlos, etc).

Este enfoque se asemeja al uso de \texttt{List<Object>} de Java/C\# que fue usado incluso antes de que estos lenguajes tuvieran tipos parametrizables, pero sin la funcionalidad de poder realizar \textit{down-casting} (castear un elemento de una superclase a una subclase).

No se utilizó este enfoque ya que al no poder obtenerse la información del tipo de \texttt{HValue} es imposible poder verificar que un record contenga campos con etiquetas y que éstos no estén repetidos, al igual que es imposible poder trabajar con tal record luego de construido.

Un ejemplo de su uso es 

\begin{code}
[HVal (1,2), HVal "Hello", HVal 42] : HList
\end{code}

\subsection{Existenciales}

\begin{code}
data HList : Type where
    Nil : HList
    (::) : {A : Type} -> (x : A) -> HList -> HList
\end{code}

Este enfoque se asemeja al uso de \textit{tipos existenciales} utilizado en Haskell. Básicamente el tipo \texttt{HList} se define como un tipo simple sin parámetros, pero sus constructores permiten utilizar valores de cualquier tipo.
Esta definición es muy similar a la que utiliza tipos dinámicos, y tiene las mismas desventajas. Luego de creada una HList de esta forma, no es posible obtener ninguna información de los tipos de los valores que contiene, por lo que es imposible poder trabajar con tales valores. Por ese motivo tampoco fue utilizado.

Un ejemplo de su uso es

\begin{code}
[1,"2"] : HList
\end{code}

\subsection{Estructurado}

\begin{code}
using (x : Type, P : x -> Type)        
    data HList : (P : x -> Type) ->  Type where
        Nil : HList P
        (::) : {head : x} -> P head -> HList P -> 
          HList P 
\end{code}

Esta definición es un punto medio (en términos de poder) entre la definición utilizada en este trabajo y las demás definiciones descritas en las secciones anteriores.

Esta HList es parametrizada sobre un constructor de tipos. Es decir, toma como parámetro una función que toma un tipo y construye otro tipo a partir de éste. Esta definición permite imponer una estructura en común a todos los elementos de la lista, forzando que cada uno de ellos haya sido construido con tal constructor de tipo, sin importar el tipo base utilizado.
La desventaja es que no es posible conocer nada de los tipos de cada elemento sin ser por la estructura que se impone en su tipo. El tipo utilizado en este trabajo (al igual que el tipo \texttt{HList} utilizado por Idris) permite utilizar tipos arbitrarios y obtener información de ellos accediendo a la lista de tipos, por lo cual son más útiles.

Algunos ejemplos son los siguientes:

\begin{code}
hListTuple : HList (\x => (x, x))
hListTuple = (1,1) :: ("1","2") :: Nil

hListExample : HList id
hListExample = 1 :: "1" :: (1,2) :: Nil
\end{code}

Como se ve en el último ejemplo, se puede reconstruir la definición de HList existencial simple utilizando \texttt{HList id}.
