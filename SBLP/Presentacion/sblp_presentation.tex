%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SBLP - Extensible Records in Idris
% Gonzalo Waszczuk - Alberto Pardo - Marcos Viera
% Instituto de Computación, Universidad de la República, Montevideo, Uruguay
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}

\mode<presentation> {

\usetheme{Madrid}
\setbeamertemplate{footline}
}

%----------------------------
%  Preamble
%----------------------------

\RequirePackage[T1]{fontenc}
\RequirePackage[iso,english]{isodate}
\RequirePackage[spanish,es-lcroman]{babel}
\RequirePackage[utf8]{inputenc}
\RequirePackage{hyperref}

\RequirePackage{graphicx}
\RequirePackage{booktabs}

%----------------------------
%	Title
%----------------------------


\title[Extensible records in Idris]{Extensible records in Idris}

\author{Gonzalo Waszczuk, Alberto Pardo, Marcos Viera}
\institute[UDELAR]
{
Instituto de Computación, Universidad de la República \\
Montevideo, Uruguay
\medskip
}

\date{August 21th, 2017}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

%----------------------------
% Presentation
%----------------------------

\section{Introduction}

\subsection{Records}

\begin{frame}[fragile]
\frametitle{Records}

Data structure composed of a collection of fields, possibly with different types and with an associated label.

\pause

\begin{example}[Record]
\begin{verbatim}
type Person = Record { surname : String, age : Int }
\end{verbatim}
\end{example}

\end{frame}

\begin{frame}[fragile]
\frametitle{Extensible Record}

Record that can be extended dynamically, adding new values with corresponding labels.

\pause

\begin{example}[Definition of record]
\begin{verbatim}
p : Record { surname : String, age : Int }
p = { surname = "Bond", age = 30 }
\end{verbatim}
\end{example}

\pause

\begin{example}[Extension of record]
\begin{verbatim}
p' : Record { name : String, surname : String, age : Int }
p' = { name = "James" } .*. p
\end{verbatim}
\end{example}

\pause

\begin{example}[Alternative definition]
\begin{verbatim}
p : Record { surname : String, age : Int }
p = { surname = "Bond" } .*.
    { age = 30 } .*.
    emptyRec
\end{verbatim}
\end{example}

\end{frame}

\begin{frame}[fragile]
\frametitle{Other operations (1)}

\begin{example}[Lookup]
\begin{verbatim}
n : String
n = p .!. surname
-- "Bond"
\end{verbatim}
\end{example}

\pause

\vspace{12pt}

\begin{example}[Update]
\begin{verbatim}
p' : Record { surname : String, age : Int }
p' = updateR surname "Dean" p
-- { surname = "Dean", age = 30 }
\end{verbatim}
\end{example}

\end{frame}

\begin{frame}[fragile]
\frametitle{Other operations (2)}

\begin{example}[Delete]
\begin{verbatim}
p' : Record { age : Int }
p' = p .//. surname
-- { age = 30 }
\end{verbatim}
\end{example}

\pause

\begin{example}[Union]
\begin{verbatim}
p' : Record { surname : String, name : String }
p' = { surname = "Bond", name = "James" }

p'' : Record { surname : String, age : Int, name : String}
p'' = p .||. p'
-- { surname = "Bond", age = 30, name = "James" }
\end{verbatim}
\end{example}

\end{frame}

\begin{frame}
\frametitle{Why use extensible records?}

\begin{itemize}
\item Dynamic data structure. Can be extended, can be reduced.
\item Fields can have arbitrary and variable types.
\item Statically typed. The type of each individual field is known.
\item Examples of uses: Language interpreter, database queries, configuration files, etc.
\end{itemize}

\end{frame}

\subsection{Other languages}

\begin{frame}
\frametitle{Current languages with extensible records}

Languages provide extensibles records via primitive features, or via libraries.

\pause

\begin{block}{Via primitive features}
Extensible records are supported by the language itself. They have special syntax and behavior in the language.

Examples: Elm, Purescript.
\end{block}

\pause

\begin{block}{Via libraries}
Extensible records are defined as components inside the language that can be used by users via libraries.

Examples: records, rawr, vinyl, HList in Haskell.
\end{block}

\end{frame}

\section{Description of this work}

\begin{frame}
\frametitle{What are we looking for?}

We are looking for a solution for extensible records that:

\begin{itemize}
\item Is typesafe
\item Covers all operations and functionalities of extensible records.
\item Is defined as a library.
\item Has extensibles records as first-class citizens.
\item Is practical to use.
\end{itemize}

\pause

Haskell's HList library fulfills these functionalities. This work is inspired by HList, adapting it to dependent types.

\end{frame}

\begin{frame}
\frametitle{Idris}

\begin{itemize}
\item This solution is based on Idris.
\item Idris is a functional, statically-typed, total, and dependently-typed language.
\item In a dependently-typed language, types can depend on values and are first-class citizens.
\end{itemize}
\end{frame}

\section{Definition of extensible records}

\subsection{Heterogeneous Lists}

\begin{frame}[fragile]
\frametitle{Records as heterogeneous lists}

\begin{example}[Original example]
\begin{verbatim}
p : Record { surname : String, age : Int }
p = { surname = "Bond" } .*.
    { age = 30 } .*.
    emptyRec
\end{verbatim}
\end{example}

\pause

An extensible record can be seen as a variable list of fields. These fields have different types, meaning the record can be represented with a \textit{heterogeneous list}.

\pause

\begin{example}[Record as a heterogeneous list]
\begin{verbatim}
p = { surname = "Bond" } ::
    { age = 30 } ::
    Nil
\end{verbatim}
\end{example}

\end{frame}

\begin{frame}[fragile]
\frametitle{Heterogeneous lists in Idris}

\begin{definition}[HList in Idris]
\begin{verbatim}
data HList : List Type -> Type where
  HNil : HList []
  (:>) : t -> HList ts -> HList (t :: ts)
\end{verbatim}
\end{definition}

\pause

\begin{definition}[Operation on HList]
\begin{verbatim}
hLength : HList ts -> Nat
hLength HNil      = 0
hLength (x :> xs) = 1 + hLength xs
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{Record defined with HList}

\begin{example}
\begin{verbatim}
p : HList [String, Int]
p = "Bond" :> 30 :> HNil
\end{verbatim}
\end{example}

\end{frame}

\subsection{Labelled HList}

\begin{frame}[fragile]
\frametitle{Labelled HList}

Where are the labels? This definition is incomplete.

\pause

\begin{definition}[Labelled HList]
\begin{verbatim}
data LHList : List (lty, Type) -> Type where
  HNil : LHList []
  (:>) : Field lty t -> LHList ts -> LHList ((lty, t) :: ts)

data Field : lty -> Type -> Type where
  (.=.) : (l : lty) -> (v : t) -> Field l t
\end{verbatim}
\end{definition}

\pause

\begin{example}[Record defined with LHList]
\begin{verbatim}
p : LHList [("surname", String), ("age", Int)]
p = ("surname" .=. "Bond") :> 
    ("age" .=. 30) :> 
    HNil
\end{verbatim}
\end{example}

\end{frame}

\subsection{Record}

\begin{frame}[fragile]
\frametitle{Repeated labels}

\begin{example}[Record with repeated labels]
\begin{verbatim}
p : LHList [("surname", String), ("surname", Int)]
p = ("surname" .=. "Bond") :> 
    ("surname" .=. 30) :> 
    HNil
\end{verbatim}
\end{example}

\pause

This case compiles, but is incorrect. The definition of extensible records should not allow the construction of records with repeated labels.

\end{frame}

\begin{frame}[fragile]
\frametitle{Complete definition of extensible record}

An extensible record is an heterogeneous list of fields with labels, such that no label is repeated.

\pause

\begin{definition}[Definition of extensible records]
\begin{verbatim}
data Record : List (lty, Type) -> Type where
  MkRecord : IsSet (labelsOf ts) -> LHList ts ->
                                    Record ts
\end{verbatim}
\end{definition}

\begin{definition}
\begin{verbatim}
labelsOf : List (lty, Type) -> List lty
labelsOf = map fst
\end{verbatim}
\end{definition}

\end{frame}

\subsection{Non-repeated labels}

\begin{frame}[fragile]
\frametitle{IsSet}

Inductive predicate over lists that indicates that there are no repeated values.

\pause

\begin{definition}[Definition of IsSet]
\begin{verbatim}
data IsSet : List t -> Type where
  IsSetNil  : IsSet []
  IsSetCons : Not (Elem x xs) -> IsSet xs
                              -> IsSet (x :: xs)
\end{verbatim}
\end{definition}

\pause

\texttt{Elem} is an inductive predicate that indicates that a value belongs to a list.

\begin{definition}[Definition of Elem]
\begin{verbatim}
data Elem : t -> List t -> Type where
  Here  : Elem x (x :: xs)
  There : Elem x xs -> Elem x (y :: xs)
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{Final construction of a record (1)}

With these definitions we can construct a record:

\begin{example}[Example of an extensible record]
\begin{verbatim}
r : Record [("surname", String), ("age", Int)]
r = MkRecord (IsSetCons not1 (IsSetCons not2 IsSetNil)) 
    (("surname" .=. "Bond") :>
    ("age" .=. 30) :>
    HNil)

not1 : Not (Elem "surname" ["age"])
not1 Here impossible

not2 : Not (Elem "age" [])
not2 Here impossible
\end{verbatim}
\end{example}
\end{frame}

\begin{frame}[fragile]
\frametitle{Final construction of a record (2)}

\begin{example}[Empty record]
\begin{verbatim}
emptyRec : Record []
emptyRec = MkRecord IsSetNil HNil
\end{verbatim}
\end{example}

\end{frame}

\subsection{Extension of a record}

\begin{frame}[fragile]
\frametitle{Extension of a record}

The extension of a record simply verifies that the label is not repeated, and then adds the field to the list of fields of the record.

\pause

\begin{definition}
\begin{verbatim}
consR : Field l t -> Not (Elem l (labelsOf ts))
                  -> Record ts
                  -> Record ((l, t) :: ts)
consR f p (MkRecord isS fs)
  = MkRecord (IsSetCons p isS) (f :> fs)
\end{verbatim}
\end{definition}

\pause
\begin{example}[Example of an extensible record]
\begin{verbatim}
r : Record [("surname", String), ("age", Int)]
r = consR ("surname" .=. "Bond") not1 $
    consR ("age" .=. 30) not2 $
    emptyRec
\end{verbatim}
\end{example}
\end{frame}

\subsection{Automatic generation of proofs}

\begin{frame}[fragile]
\frametitle{Automatic generation of proofs (1)}

The previous definition has a problem. It is always necessary to provide the proof of a label not being repeated. \\

We can improve it by automatically generating the proof at compilation time.

\end{frame}

\begin{frame}[fragile]
\frametitle{Automatic generation of proofs (2)}

To be able to generate the proofs, we can use the fact that belonging to a list is a decidable predicate. \\

A predicate is decidable if you can always get a proof of it or its negation.

\pause

\begin{definition}[Definition of decidabilty in Idris]
\begin{verbatim}
data Dec : Type -> Type where
  Yes : prop     -> Dec prop
  No  : Not prop -> Dec prop

interface DecEq t where
  total decEq : (x1 : t) -> 
                (x2 : t) -> Dec (x1 = x2)
\end{verbatim}
\end{definition}

\pause

\begin{definition}[Decidability function of Elem]
\begin{verbatim}
isElem : DecEq t => (x : t) -> (xs : List t) -> 
         Dec (Elem x xs)
\end{verbatim}
\end{definition}

\end{frame}


\begin{frame}[fragile]
\frametitle{Automatic generation of proofs (3)}

We can use the decidability of a predicate to get a proof of it or its negation in compilation time. Depending on the result, we can unify it with our expected type or unify it with unit.

\pause

\begin{definition}
\begin{verbatim}
MaybeE : DecEq lty => lty -> List (lty, Type) -> Type -> Type
MaybeE l ts r = UnitOrType (isElem l (labelsOf ts)) r

UnitOrType : Dec p -> Type -> Type
UnitOrType (Yes _) _   = ()
UnitOrType (No no) res = res

mkUorT : (d : Dec p) -> (f : Not p -> res)
                     -> UnitOrType d res
mkUorT (Yes _) _ = ()
mkUorT (No no) f = f no
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{New definition of record extension (1)}

With this new technique, we can redefine consR so that it automatically generates the proof of the label not belonging to the record.

\pause

\begin{definition}
\begin{verbatim}
(.*.) : DecEq lty => {l : lty} ->
        Field l t -> Record ts ->
        MaybeE l ts (Record ((l, t) :: ts))
(.*.) {ts} f@(l .=. v) (MkRecord isS fs)
  = mkUorT (isElem l (labelsOf ts))
           (\notp => MkRecord (IsSetCons notp isS) (f :> fs))
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{New definition of record extension (2)}

\begin{example}[Original example with new extension operator]
\begin{verbatim}
r : Record [("surname", String), ("age", Int)]
r = ("surname" .=. "Bond") .*.
    ("age" .=. 30) .*.
    emptyRec
\end{verbatim}
\end{example}

\end{frame}

\section{Operations on records}

\subsection{Lookup}

\begin{frame}[fragile]
\frametitle{Lookup (1)}

To implement lookup we first need to find the type of a label that belongs to the record:

\begin{definition}
\begin{verbatim}
getType : (ts : List (lty, Type)) -> Elem l (labelsOf ts) -> 
          Type
getType ((l, ty) :: ts) Here      = ty
getType ((l, ty) :: ts)(There th) = getType ts th
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{Lookup (2)}

We can use the previous function to implement lookup:

\begin{definition}
\begin{verbatim}
lookupR : (l : lty) -> Record ts -> 
          (elem : Elem l (labelsOf ts)) -> getType ts elem
lookupR l (MkRecord _ fs) elem = lookupH l fs elem

lookupH : (l : lty) -> LHList ts -> 
          (elem : Elem l (labelsOf ts)) -> getType ts elem
lookupH _ ((_ .=. v) :: _) Here   = v
lookupH l (_ :: hs) (There th)    = lookupH l hs th
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{Lookup (3)}

We can use a similar technique as the one used in record extension to dynamically construct a proof of the \texttt{Elem} predicate and define the lookup operator:

\begin{definition}
\begin{verbatim}
MaybeLkp : DecEq lty => List (lty, Type) -> lty -> Type
MaybeLkp ts l = TypeOrUnit2 (isElem l (labelsOf ts))
                            (\isE => getType ts isE)

(.!.) : DecEq lty => Record ts -> (l : lty) -> 
        MaybeLkp ts l
(.!.) {ts} r l = mkTorU2 (isElem l (labelsOf ts))
                         (\isE => getType ts isE)
                         (\isE => lookupR l r isE)
\end{verbatim}
\end{definition}

\end{frame}

\begin{frame}[fragile]
\frametitle{Lookup (4)}

The operator uses a similar definition of \texttt{UnitOrType}, but it acts on the \texttt{Yes} predicate and uses a type constructor to compute the returning type.

\begin{definition}
\begin{verbatim}
TypeOrUnit2 : Dec p -> (p -> Type) -> Type
TypeOrUnit2 (Yes yes) tyCons = tyCons yes
TypeOrUnit2 (No _) _         = ()

mkTorU2 : (d : Dec p) -> (tyCons : p -> Type) -> 
          (f : (prf : p) -> tyCons prf) ->
          TypeOrUnit2 d tyCons
mkTorU2 (Yes yes) _ f = f yes
mkTorU2 (No _) _ _    = ()
\end{verbatim}
\end{definition}

\end{frame}


\subsection{Other operations}

\begin{frame}[fragile]
\frametitle{Other operations (1)}

\begin{block}{Append}
Concats the fields of two records, but only if there are no repeated labels.

\begin{definition}
\begin{verbatim}
MaybeApp : DecEq lty => List (lty, Type) ->
           List (lty, Type) -> Type -> Type
MaybeApp ts us r = 
    TypeOrUnit (isSet (labelsOf (ts ++ us))) r

(.++.) : DecEq lty => {ts : List (lty, Type)} -> Record ts -> 
         Record us -> MaybeApp ts us (Record (ts ++ us))
\end{verbatim}
\end{definition}

\end{block}

\end{frame}

\begin{frame}[fragile]
\frametitle{Other operations (2)}

\begin{block}{Project}
Returns fields from a record by checking if they belong to a given list or not.

\begin{definition}
\begin{verbatim}
(.<.) : DecEq lty => {ts : List (lty, Type)} -> 
        (ls : List lty) -> Record ts -> 
        Record (ls :<: ts)

(.>.) : DecEq lty => {ts : List (lty, Type)} -> 
        (ls : List lty) -> Record ts -> 
        Record (ls :>: ts)
\end{verbatim}
\end{definition}

\end{block}

\end{frame}

\begin{frame}[fragile]
\frametitle{Other operations (3)}

\begin{block}{Left Union}
Takes two records and returns the left union of both.

\begin{definition}
\begin{verbatim}
(.||.) : DecEq lty => {ts, us : List (lty, Type)} -> 
         Record ts -> Record us -> Record (ts :||: us)
\end{verbatim}
\end{definition}

\end{block}

\begin{block}{Update}

Updates the value of a particular field.

\begin{definition}
\begin{verbatim}
MaybeUpd : DecEq lty => List (lty, Type) -> lty -> Type
MaybeUpd ts l = TypeOrUnit2 (isElem l (labelsOf ts))
                (\isE => getType ts isE -> Record ts)

updR : DecEq lty => (l : lty) -> Record ts -> MaybeUpd ts l
\end{verbatim}
\end{definition}

\end{block}
\end{frame}

\section{Conclusiones y final}

\begin{frame}
\frametitle{Conclusions (1)}

The principal objectives of this work were achieved:

\begin{itemize}
\item The solution is exposed as an user library.
\item It's typesafe.
\item Extensible records are first-class citizens.
\item It covers the functionalities and operations of extensible records.
\item It's relatively practical to use.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Conclusions (2)}

Other conclusions:

\begin{itemize}
\item Development in dependently-typed languages is relatively direct and easy.
\item Most dificulties are found in theorem proving, not in the development itself.
\item A good type and predicate design is needed.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Future Work}

We identified various aspects of this library to improve in the future:

\begin{itemize}
\item Implement the rest of the operations on extensible records.
\item Parametrize the record by a sorted list or abstract type, not an ordered list.
\item Replicate this library in Agda
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{End}

\begin{center}
{\huge Thanks!}
\end{center}

\vfill

\vfill

\begin{center}
GitHub: \url{https://github.com/gonzaw/extensible-records}
\end{center}

\end{frame}

\end{document} 
